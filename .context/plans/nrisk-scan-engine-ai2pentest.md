---
status: in_progress
generated: 2026-02-04
source: Scan Engine n.Risk baseado em AI2PentestTool
repository: https://github.com/penligent/AI2PentestTool
parentPlan: nrisk-arquitetura-gcp
agents:
  - type: "backend-specialist"
    role: "Wrapper Go, execução de ferramentas, parsers"
  - type: "architect-specialist"
    role: "Manifesto de ferramentas, pipeline de dados"
  - type: "security-auditor"
    role: "Modo não intrusivo, mapeamento ISO"
docs:
  - "architecture.md"
  - "data-flow.md"
phases:
  - id: "mapeamento"
    name: "Mapeamento de Origem (AI2PentestTool)"
    prevc: "P"
  - id: "wrapper"
    name: "Implementação do Wrapper Go"
    prevc: "E"
  - id: "parsers"
    name: "Parser de Conformidade (ISO 27001)"
    prevc: "E"
  - id: "infra"
    name: "Infraestrutura Cloud Run Jobs"
    prevc: "E"
---

# Scan Engine n.Risk baseado em AI2PentestTool

> Wrapper Go que utiliza a agilidade de setup do [AI2PentestTool](https://github.com/penligent/AI2PentestTool) para alimentar o sistema de Score de Risco do n.Risk. Foco em scans **não intrusivos** e output estruturado para Firestore.

## Task Snapshot

- **Primary goal:** Motor de scan em Go que executa ferramentas do AI2PentestTool, parseia output e grava findings em `tenants/{tenant_id}/findings/{finding_id}` no Firestore.
- **Success signal:** Cloud Run Job executa scan por domínio; findings JSON no Firestore; mapeamento para controles ISO 27001.
- **Key references:**
  - [AI2PentestTool](https://github.com/penligent/AI2PentestTool)
  - [Matriz GRC](./nrisk-matriz-rastreabilidade-grc.md)
  - [Arquitetura GCP](./nrisk-arquitetura-gcp.md)

---

## 1. Mapeamento de Origem (AI2PentestTool)

### 1.1 Estrutura do Repositório Base

| Arquivo | Função |
|---------|--------|
| `config.py` | `TOOLS_INFO`: nome, description, macos/linux/windows (install), verify_command, category |
| `tool_installer.py` | `subprocess.run()` para executar comandos; timeout 300s; verificação pós-install |
| `main.py` | CLI: install, install-default, install-file, list, show-tools |
| `tools_config.json` | Gerado após instalação: path, command, category |

### 1.2 Ferramentas Relevantes para n.Risk (Não Intrusivas)

| Ferramenta | Categoria AI2Pentest | Uso n.Risk | Comando Execução |
|------------|----------------------|------------|-------------------|
| **dig** | Information Gathering | DNS, SPF, DMARC | `dig TXT +short {domain}` |
| **sslyze** | SSL/TLS Testing | Certificado, TLS | `sslyze --json_out=- {domain}:443` |
| **nmap** | Network Scanning | Portas críticas (modo -sV leve) | `nmap -sV -p 3389,445,22,80,443 {target}` |
| **amass** | Information Gathering | Subdomínios (passivo) | `amass enum -passive -d {domain}` |
| **curl** | Network Tools | Headers HTTP (HSTS, CSP) | `curl -sI https://{domain}` |
| **whois** | Information Gathering | Informações do domínio | `whois {domain}` |

**Excluídas** (intrusivas): sqlmap, nikto, wfuzz, gobuster, dirsearch, masscan (alto volume).

### 1.3 Padrão de Comandos AI2PentestTool

- **Instalação Linux:** `apt update && apt install -y <pkg>`
- **Verificação:** `{tool} --version` ou `{tool} -v`
- **Execução:** Não definida no AI2PentestTool — apenas instalação. O n.Risk define comandos de execução.

---

## 2. Manifesto de Ferramentas para o Scan Engine

Estrutura YAML/JSON adaptada do `TOOLS_INFO`:

```yaml
tools:
  dig:
    category: dns
    run_command: "dig TXT {domain} +short"
    run_command_spf: "dig TXT {domain} +short"
    run_command_dmarc: "dig TXT _dmarc.{domain} +short"
    output_format: text
  sslyze:
    category: ssl
    run_command: "sslyze --json_out=- {domain}:443"
    output_format: json
  nmap:
    category: port_scan
    run_command: "nmap -sV -Pn -p 22,80,443,3389,445 --open -oG - {target}"
    output_format: grepable
  amass:
    category: subdomain
    run_command: "amass enum -passive -d {domain} -json -"
    output_format: jsonlines
  curl:
    category: headers
    run_command: "curl -sI -m 10 https://{domain}"
    output_format: text
```

---

## 3. Parser de Conformidade (ISO 27001)

### 3.1 Mapeamento Achado Técnico → Controle ISO

| Achado (technical_finding) | Ferramenta | Controle | ISO |
|---------------------------|------------|----------|-----|
| `open_rdp_port` | nmap | C-01 | A.13.1.1 |
| `open_smb_port` | nmap | C-01 | A.13.1.1 |
| `expired_ssl` | sslyze | C-02 | A.10.1.1 |
| `ssl_expires_soon` | sslyze | C-02 | A.10.1.1 |
| `weak_tls` | sslyze | C-02 | A.10.1.1 |
| `missing_dmarc` | dig | C-04 | A.13.2.1 |
| `dmarc_none` | dig | C-04 | A.13.2.1 |
| `missing_spf` | dig | C-04 | A.13.2.1 |
| `missing_hsts` | curl | C-03 | A.12.6.1 |
| `missing_csp` | curl | C-03 | A.12.6.1 |

### 3.2 Estrutura do Finding (Firestore)

```json
{
  "id": "finding-uuid",
  "tenant_id": "org-123",
  "scan_id": "scan-uuid",
  "domain": "example.com",
  "technical_finding": "expired_ssl",
  "control_id": "C-02",
  "iso_domain": "A.10.1.1",
  "severity": "high",
  "title": "Certificado SSL expirado",
  "detail": "O certificado expirou em 2025-01-15",
  "raw_output": "...",
  "tool": "sslyze",
  "created_at": "2026-02-04T10:00:00Z"
}
```

**Caminho Firestore:** `tenants/{tenant_id}/findings/{finding_id}`

---

## 4. Wrapper Go — Arquitetura

### 4.1 Estrutura de Pastas

```
scan-engine/
├── cmd/job/main.go           # Entrypoint Cloud Run Job
├── internal/
│   ├── config/
│   │   └── tools.go          # Manifesto de ferramentas
│   ├── runner/
│   │   └── runner.go         # Executa ferramenta via exec.Command
│   ├── parsers/
│   │   ├── dig.go
│   │   ├── sslyze.go
│   │   ├── nmap.go
│   │   ├── curl.go
│   │   └── registry.go       # Registry de parsers
│   ├── mapper/
│   │   └── iso.go            # technical_finding → control_id
│   ├── store/
│   │   └── firestore.go      # Salva em tenants/{id}/findings
│   └── scan/
│       └── orchestrator.go   # Orquestra dig→sslyze→nmap→...
├── tools.yaml                # Manifesto
├── Dockerfile                # Imagem com ferramentas pré-instaladas
└── go.mod
```

### 4.2 Fluxo de Execução

1. **Input:** Variáveis de ambiente `TENANT_ID`, `SCAN_ID`, `DOMAIN`
2. **Orquestrador:** Para cada ferramenta no manifesto (dig, sslyze, nmap, curl):
   - Executa comando (substitui `{domain}`)
   - Captura stdout/stderr
   - Chama parser correspondente
   - Obtém lista de findings
3. **Mapper:** Para cada finding, consulta `technical_finding` → `control_id`, `iso_domain`, `severity`
4. **Store:** Persiste em Firestore `tenants/{tenant_id}/findings/{finding_id}`

### 4.3 Comandos por Ferramenta (Não Intrusivos)

| Tool | Comando | Parser |
|------|---------|--------|
| dig | `dig TXT {domain} +short; dig TXT _dmarc.{domain} +short` | Regex: SPF, DMARC p= |
| sslyze | `sslyze --json_out=- {domain}:443` | JSON: certificate.expired, tls_version |
| nmap | `nmap -sV -Pn -p 22,80,443,3389,445 -T2 --open -oG - {domain}` | Grepable: port 3389/445 open |
| curl | `curl -sI -m 10 https://{domain}` | Regex: Strict-Transport-Security, Content-Security-Policy |

---

## 5. Infraestrutura Serverless (Cloud Run Jobs)

### 5.1 Dockerfile

```dockerfile
# Base com ferramentas pré-instaladas (espelhando AI2PentestTool)
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y \
    dnsutils \
    sslyze \
    nmap \
    amass \
    curl \
    whois \
    ca-certificates
COPY scan-engine /app
WORKDIR /app
ENTRYPOINT ["/app/scan-engine"]
```

### 5.2 Variáveis de Ambiente (Job)

| Variável | Descrição |
|----------|-----------|
| `TENANT_ID` | Tenant do scan |
| `SCAN_ID` | ID do scan (para correlacionar) |
| `DOMAIN` | Domínio alvo |
| `GCP_PROJECT_ID` | Projeto Firestore |

### 5.3 Trigger

- Pub/Sub: mensagem `{ tenant_id, scan_id, domain }`
- Cloud Run Jobs: cada execução é um job efêmero
- Timeout: 5 min (NFR do PRD)

---

## 6. Regra de Ouro

> **Não criar pentest genérico.** Usar a agilidade de setup do AI2PentestTool para alimentar Score de Risco para Seguradoras.

- **Modo:** Apenas ferramentas não intrusivas (reconhecimento, DNS, SSL, headers)
- **Output:** JSON estruturado para Firestore
- **Formato:** `tenants/{tenant_id}/findings/{finding_id}`
- **Objetivo:** Insumo para algoritmo de scoring e matriz de validação cruzada

---

## 7. Firestore — Atualização das Rules

Adicionar regra para `findings`:

```
match /tenants/{tenantId}/findings/{findingId} {
  allow read, write: if isTenantMember(tenantId);
}
```

---

## 8. Próximos Passos

1. Criar repositório/subpasta `scan-engine/` no n.Risk
2. Implementar manifesto `tools.yaml`
3. Implementar runner e parsers em Go
4. Implementar store Firestore
5. Dockerfile com ferramentas
6. Integrar com Pub/Sub (consumir mensagens da API)
